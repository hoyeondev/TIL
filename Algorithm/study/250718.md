## 1. 슬라이딩 윈도우
배열이나 리스트에서 고정 사이즈의 윈도우가 이동하면서 윈도우 내에 있는 데이터를 이용해 문제를 풀이하는 알고리즘
<br>
윈도우를 한 칸씩 **밀면서(slide)** 전체 데이터를 확인한다.

- **연속된 구간**을 다루는 문제에 적합
- 시간 복잡도를 줄일 수 있음 (보통 `O(n)`으로 최적화)
- 누적합, 최댓값, 최소값 등을 빠르게 계산 가능

#### 💡 슬라이딩 윈도우 사용 예시
- 고정 길이의 부분 배열에서 최대 합 구하기
- 특정 조건을 만족하는 부분 문자열 찾기
- 두 배열의 윈도우 비교 등

#### 예제1 ) 최대 슬라이딩 윈도우
```python
## 배열 nums가 주어졌을 때 k 크기의 슬라이딩 윈도우를 오른쪽 끝까지 이동하면서
## 최대 슬라이딩 윈도우를 구하라.

from typing import List

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        if not nums:
            return nums

        r = []
        for i in range(len(nums) - k + 1):
            r.append(max(nums[i:i + k]))

        return r

sol = Solution()
print(sol.maxSlidingWindow([1,3,-1,-3,5,3,6,7], 3))

# 윈도우가 이동하면서 3개의 숫자씩 묶어서 그 중 최댓값을 하나씩 뽑는다.
# 출력 : [3, 3, 5, 5, 6, 7]
```

#### 예제2 ) 부분 문자열이 포함된 최소 윈도우
```python
# 문자열 S와 T를 입력받아 O(n)에 T의 모든 문자가 포함된 S의
# 최소 윈도우를 찾아라.

# 투 포인터, 슬라이딩 윈도우로 최적화
import collections

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        need = collections.Counter(t)
        missing = len(t)
        left = start = end = 0
        
        # 오른쪽 포인터 이동
        for right, char in enumerate(s, 1):
            missing -= need[char] > 0
            need[char] -= 1
            
            # 필요 문자가 0이면 왼쪽 포인터 이동 판단
            if missing == 0:
                while left < right and need[s[left]] < 0:
                    need[s[left]] += 1
                    left += 1
                    
                if not end or right - left <= end - start:
                    start, end = left, right
                need[s[left]] += 1
                missing += 1
                left += 1
            
        return s[start:end]
        
sol = Solution()
print(sol.minWindow("ADOBECODEBANC", "ABC"))

# 출력 : BANC
```

#### 예제3 ) 가장 긴 반복 문자 대체
```python
# 대문자로 구성된 문자열 s가 주어졌을 때 k번만큼의 변경으로 만들 수 있는,
# 연속으로 반복된 문자열의 가장 긴 길이를 출력하라.

import collections

class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        left = right = 0
        counts = collections.Counter()
        for right in range(1, len(s) + 1):
            counts[s[right - 1]] += 1
            # 가장 흔하게 등장하는 문자 탐색
            max_char_n = counts.most_common(1)[0][1]
            
            # k 초과시 왼쪽 포인터 이동
            if right - left - max_char_n > k:
                counts[s[left]] -= 1
                left += 1
        return right - left
    
sol = Solution()
print(sol.characterReplacement("AAABBC", 2))

# B를 A로 각각 2번 변경하면 길이 5인 AAAAA를 만들 수 있다.
# 출력 : 5

```
